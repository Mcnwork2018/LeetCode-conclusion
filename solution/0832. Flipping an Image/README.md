# 翻转图像

### 题目描述

给定一个二进制矩阵 `A`，我们想先水平翻转图像，然后反转图像并返回结果。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 `[1, 1, 0]` 的结果是 `[0, 1, 1]`。

反转图片的意思是图片中的 `0` 全部被 `1` 替换， `1` 全部被 `0` 替换。例如，反转 `[0, 1, 1]` 的结果是 `[1, 0, 0]`。

**示例 1**

```
输入: [[1,1,0],[1,0,1],[0,0,0]]
输出: [[1,0,0],[0,1,0],[1,1,1]]
解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
      然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
```

**示例 2**

```
输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
```

**说明**

- `1 <= A.length = A[0].length <= 20`
- `0 <= A[i][j] <= 1`

### 解法

**第一种解法**

**思路**

实际上，对数组进行翻转并取反，数组只需要对比对称位上的数组是否相同，如果相同，就进行取反，如果不同，则不去取反，以为当对称位数字不同，进行一次翻转后在取反和原先的数字是相同的。

**算法**

```javascript
var flipAndInvertImage = function(A) {
  const len = A.length;
  for (let k = 0; k < len; k++ ) {
    let j = len - 1;
    for(let i = 0; i <= ~~( j / 2 ); i++){
      if ( A[k][i] === A[k][j - i] ) {
        A[k][i] === 1 ? A[k][i] = A[k][j - i] = 0 : A[k][i] = A[k][j - i] = 1;
      }
    }
  }
  return A;
}
```

**复杂度分析**

暂无

**第二种解法**

**思路**

正常的进行交换取反值。这个解法中双非~~和 按位异或 ^ 的用法非常棒。

**算法**

```javascript
var flipAndInvertImage2 = function(A) {
  for (let i = 0; i < A.length; ++i) {
    let last = A[i].length - 1;
    for (let j = 0; j <= ~~(last / 2); ++j) {
      [ A[i][j], A[i][last - j] ] = [ A[i][last - j] ^ 1, A[i][j] ^ 1 ];
    }
  }
  return A;
};
```

**复杂度分析**

暂无